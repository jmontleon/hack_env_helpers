---
- name: Launch AWS Windows instance and install VSCode extension
  hosts: localhost
  gather_facts: false
  vars:
    aws_region: "us-east-1"
    ec2_instance_type: "m5.4xlarge"
    resource_prefix: "{{ guid }}"
    instance_name: "{{ resource_prefix }}-instance"
    proxy_instance_name: "{{ resource_prefix }}-proxy-instance"
    vpc_name: "{{ resource_prefix }}-vpc"
    subnet_name: "{{ resource_prefix }}-subnet"
    igw_name: "{{ resource_prefix }}-igw"
    route_table_name: "{{ resource_prefix }}-rt"
    security_group_name: "{{ resource_prefix }}-sg"
    proxy_security_group_name: "{{ resource_prefix }}-proxy-sg"
    key_pair_name: "{{ resource_prefix }}-keypair"
    cleanup_resources: true # cleans up all dependent resources
    winrm_wait_timeout: 180 # 3 minutes default wait for WinRM
    disable_http2: false # Set to true to enable mitmproxy with WireGuard
    proxy_instance_type: "t3.medium"
  tasks:
    - name: Validate required variables
      fail:
        msg: "Required variable {{ item }} is not defined"
      when: vars[item] is not defined or vars[item] == ""
      loop:
        - aws_access_key_id
        - aws_secret_access_key
        - user_email
        - action
    
    - name: GH Token validation
      fail:
        msg: "Required variable gh_token is not defined"
      when: (gh_token is not defined or gh_token == "") and konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$'))

    - block:
        - name: Get latest Windows Server 2022 AMI
          amazon.aws.ec2_ami_info:
            region: "{{ aws_region }}"
            owners:
              - amazon
            filters:
              name: "Windows_Server-2022-English-Full-Base-*"
              architecture: x86_64
              virtualization-type: hvm
              state: available
          register: windows_ami_info

        - name: Set Windows AMI ID
          set_fact:
            ec2_image_id: "{{ (windows_ami_info.images | sort(attribute='creation_date') | last).image_id }}"

        - name: Display selected AMI
          debug:
            msg: "Using Windows AMI: {{ ec2_image_id }} ({{ (windows_ami_info.images | sort(attribute='creation_date') | last).name }})"

        - name: Get latest Fedora AMI for proxy
          amazon.aws.ec2_ami_info:
            region: "{{ aws_region }}"
            owners:
              - "125523088429"  # Fedora
            filters:
              name: "Fedora-Cloud-Base-*"
              architecture: x86_64
              virtualization-type: hvm
              state: available
          register: fedora_ami_info
          when: disable_http2 | bool

        - name: Fail if no Fedora AMI found
          fail:
            msg: "No Fedora AMI found in {{ aws_region }}. Please check the region or use a different Linux distribution."
          when: disable_http2 | bool and (fedora_ami_info.images | default([]) | length == 0)

        - name: Set Fedora AMI ID
          set_fact:
            proxy_image_id: "{{ (fedora_ami_info.images | sort(attribute='creation_date') | last).image_id }}"
          when: disable_http2 | bool and (fedora_ami_info.images | default([]) | length > 0)

        - name: Display selected Fedora AMI
          debug:
            msg: "Using Fedora AMI for proxy: {{ proxy_image_id }} ({{ (fedora_ami_info.images | sort(attribute='creation_date') | last).name }})"
          when: disable_http2 | bool and proxy_image_id is defined

        - name: Create VPC
          amazon.aws.ec2_vpc_net:
            name: "{{ vpc_name }}"
            cidr_block: "10.0.0.0/16"
            region: "{{ aws_region }}"
            state: present
            tags:
              Environment: "konveyor-test"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: vpc_result

        - name: Create Internet Gateway
          amazon.aws.ec2_vpc_igw:
            vpc_id: "{{ vpc_result.vpc.id }}"
            region: "{{ aws_region }}"
            state: present
            tags:
              Name: "{{ igw_name }}"
              Environment: "konveyor-test"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: igw_result
          when: vpc_result.vpc.id is defined

        - name: Get availability zones that support the instance type
          command: >
            aws ec2 describe-instance-type-offerings
            --location-type availability-zone
            --filters Name=instance-type,Values={{ ec2_instance_type }}
            --region {{ aws_region }}
            --query 'InstanceTypeOfferings[*].Location'
            --output text
          environment:
            AWS_ACCESS_KEY_ID: "{{ aws_access_key_id }}"
            AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key }}"
          register: supported_azs
          changed_when: false

        - name: Parse supported availability zones
          set_fact:
            available_zones: "{{ supported_azs.stdout.split() }}"

        - name: Fail if no availability zones support this instance type
          fail:
            msg: "No availability zones in {{ aws_region }} support {{ ec2_instance_type }}"
          when: available_zones | length == 0

        - name: Select first available zone
          set_fact:
            selected_az: "{{ available_zones[0] }}"

        - name: Display selected availability zone
          debug:
            msg: "Using availability zone {{ selected_az }} for {{ ec2_instance_type }}"

        - name: Create subnet
          amazon.aws.ec2_vpc_subnet:
            vpc_id: "{{ vpc_result.vpc.id }}"
            cidr: "10.0.1.0/24"
            az: "{{ selected_az }}"
            region: "{{ aws_region }}"
            state: present
            map_public: true
            tags:
              Name: "{{ subnet_name }}"
              Environment: "konveyor-test"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: subnet_result
          when: vpc_result.vpc.id is defined

        - name: Create route table
          amazon.aws.ec2_vpc_route_table:
            vpc_id: "{{ vpc_result.vpc.id }}"
            region: "{{ aws_region }}"
            routes:
              - dest: "0.0.0.0/0"
                gateway_id: "{{ igw_result.gateway_id }}"
            subnets:
              - "{{ subnet_result.subnet.id }}"
            tags:
              Name: "{{ route_table_name }}"
              Environment: "konveyor-test"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          when: vpc_result.vpc.id is defined

        - name: Create security group
          amazon.aws.ec2_security_group:
            name: "{{ security_group_name }}"
            description: "Security group for Konveyor Windows test"
            vpc_id: "{{ vpc_result.vpc.id }}"
            region: "{{ aws_region }}"
            rules:
              - proto: tcp
                ports:
                  - 3389
                cidr_ip: "0.0.0.0/0"
                rule_desc: "RDP access"
              - proto: tcp
                ports:
                  - 5986
                cidr_ip: "0.0.0.0/0"
                rule_desc: "WinRM HTTPS"
            tags:
              Name: "{{ security_group_name }}"
              Environment: "kai-ci-extension"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: sg_result
          when: vpc_result.vpc.id is defined

        - name: Create security group for proxy instance
          amazon.aws.ec2_security_group:
            name: "{{ proxy_security_group_name }}"
            description: "Security group for mitmproxy WireGuard proxy"
            vpc_id: "{{ vpc_result.vpc.id }}"
            region: "{{ aws_region }}"
            rules:
              - proto: tcp
                ports:
                  - 22
                cidr_ip: "0.0.0.0/0"
                rule_desc: "SSH access"
              - proto: udp
                ports:
                  - 51820
                cidr_ip: "0.0.0.0/0"
                rule_desc: "WireGuard VPN"
              - proto: icmp
                from_port: -1
                to_port: -1
                cidr_ip: "10.0.0.0/16"
                rule_desc: "ICMP within VPC"
            tags:
              Name: "{{ proxy_security_group_name }}"
              Environment: "kai-ci-extension"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: proxy_sg_result
          when: vpc_result.vpc.id is defined and disable_http2 | bool

        - name: Create EC2 key pair
          amazon.aws.ec2_key:
            name: "{{ key_pair_name }}"
            region: "{{ aws_region }}"
            state: present
          register: keypair_result

        - name: Save private key
          copy:
            content: "{{ keypair_result.key.private_key }}"
            dest: "./{{ key_pair_name }}.pem"
            mode: '0600'
          when: keypair_result.key.private_key is defined

        - name: Check if instance already exists
          amazon.aws.ec2_instance_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ instance_name }}"
              instance-state-name: ["pending","running", "stopping", "stopped"]
          register: existing_instance_check

        - name: Launch EC2 instance
          amazon.aws.ec2_instance:
            name: "{{ instance_name }}"
            image_id: "{{ ec2_image_id }}"
            instance_type: "{{ ec2_instance_type }}"
            key_name: "{{ key_pair_name }}"
            security_group: "{{ sg_result.group_id }}"
            subnet_id: "{{ subnet_result.subnet.id }}"
            region: "{{ aws_region }}"
            wait: true
            wait_timeout: 600
            state: present
            tags:
              Environment: "kai-ci-extension"
              Purpose: "extension-install"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
            user_data: |
              <powershell>
              # Start logging
              Start-Transcript -Path "C:\UserDataSetup.log" -Append
              Write-Output "Starting user data script execution at $(Get-Date)"
              
              # Enable WinRM for Ansible with proper firewall configuration
              Enable-PSRemoting -Force
              Set-Item WSMan:\localhost\Client\TrustedHosts -Value "*" -Force
              
              # Configure WinRM listener and firewall rules
              winrm quickconfig -q -force
              winrm set winrm/config/winrs '@{MaxMemoryPerShellMB="1024"}'
              winrm set winrm/config '@{MaxTimeoutms="1800000"}'

              # Create self-signed certificate for HTTPS
              $cert = New-SelfSignedCertificate -DnsName "winrm-ec2" -CertStoreLocation "Cert:\LocalMachine\My" -NotAfter (Get-Date).AddYears(5)

              # Create HTTPS listener
              New-Item -Path WSMan:\localhost\Listener -Transport HTTPS -Address * -CertificateThumbprint $cert.Thumbprint -Force

              # Enable CredSSP authentication (optional, but useful for double-hop scenarios)
              winrm set winrm/config/service/auth '@{CredSSP="true"}'
              
              # Configure Windows Firewall to disable HTTP and allow only HTTPS for WinRM
              netsh advfirewall firewall set rule name="Windows Remote Management (HTTP-In)" new enable=no
              netsh advfirewall firewall add rule name="WinRM-HTTPS" dir=in action=allow protocol=TCP localport=5986

              # Enable RDP explicitly
              Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
              Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

              Write-Output "User data script completed at $(Get-Date)"
              Stop-Transcript
              </powershell>
          register: ec2_result
          when: sg_result.group_id is defined and subnet_result.subnet.id is defined and (existing_instance_check.instances | length == 0)

        - name: Start existing instance if it is stopped
          amazon.aws.ec2_instance:
            instance_ids:
              - "{{ existing_instance_check.instances[0].instance_id }}"
            region: "{{ aws_region }}"
            state: running
            wait: true
            wait_timeout: 600
          when: 
            - existing_instance_check.instances | length > 0
            - existing_instance_check.instances[0].state.name == "stopped"

        - name: Re-gather instance information
          amazon.aws.ec2_instance_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ instance_name }}"
              instance-state-name: ["running"]
          register: existing_instance_check

        - name: Use existing instance if available and running
          set_fact:
            instance_ip: "{{ existing_instance_check.instances[0].public_ip_address }}"
            instance_id: "{{ existing_instance_check.instances[0].instance_id }}"
          when: existing_instance_check.instances | length > 0 and existing_instance_check.instances[0].state.name == "running"

        - name: Get instance information from new deployment
          set_fact:
            instance_ip: "{{ ec2_result.instances[0].public_ip_address }}"
            instance_id: "{{ ec2_result.instances[0].instance_id }}"
          when: ec2_result.instances is defined and ec2_result.instances | length > 0

        - name: Wait for WinRM to become available
          wait_for:
            host: "{{ instance_ip }}"
            port: 5986
            delay: 30
            timeout: 1000
            msg: "WinRM HTTPS service not available after 15 minutes"
 
        - name: Get Windows Administrator password
          community.aws.ec2_win_password:
            instance_id: "{{ instance_id }}"
            region: "{{ aws_region }}"
            key_file: "./{{ key_pair_name }}.pem"
            wait: true
            wait_timeout: 900
          register: admin_pw

        - name: Save connection information
          set_fact:
            windows_instance_id: "{{ instance_id }}"
            windows_instance_ip: "{{ instance_ip }}"
            windows_admin_password: "{{ admin_pw.win_password }}"
            nonadmin_password: "{{ admin_pw.win_password }}"
            cacheable: yes

        - name: Add Windows host to inventory
          add_host:
            hostname: "{{ instance_ip }}"
            groupname: windows_hosts
            ansible_host: "{{ instance_ip }}"
            ansible_user: Administrator
            ansible_password: "{{ admin_pw.win_password }}"
            ansible_connection: winrm
            ansible_winrm_transport: ntlm
            ansible_winrm_server_cert_validation: ignore
            ansible_winrm_message_encryption: auto
            ansible_port: 5986
            ansible_winrm_operation_timeout_sec: 60
            ansible_winrm_read_timeout_sec: 100
            instance_id: "{{ instance_id }}"

        - name: Launch Linux proxy instance
          amazon.aws.ec2_instance:
            name: "{{ proxy_instance_name }}"
            image_id: "{{ proxy_image_id }}"
            instance_type: "{{ proxy_instance_type }}"
            key_name: "{{ key_pair_name }}"
            security_group: "{{ proxy_sg_result.group_id }}"
            subnet_id: "{{ subnet_result.subnet.id }}"
            region: "{{ aws_region }}"
            wait: true
            wait_timeout: 600
            state: present
            tags:
              Environment: "kai-ci-extension"
              Purpose: "mitmproxy-wireguard"
              CreatedBy: "ansible"
              Owner: "{{ user_email }}"
          register: proxy_ec2_result
          when: disable_http2 | bool and proxy_sg_result.group_id is defined

        - name: Get proxy instance information
          set_fact:
            proxy_instance_ip: "{{ proxy_ec2_result.instances[0].public_ip_address }}"
            proxy_instance_id: "{{ proxy_ec2_result.instances[0].instance_id }}"
            proxy_instance_private_ip: "{{ proxy_ec2_result.instances[0].private_ip_address }}"
          when: disable_http2 | bool and proxy_ec2_result.instances is defined

        - name: Wait for SSH to become available on proxy
          wait_for:
            host: "{{ proxy_instance_ip }}"
            port: 22
            delay: 10
            timeout: 300
            msg: "SSH service not available after 5 minutes"
          when: disable_http2 | bool and proxy_instance_ip is defined

        - name: Save proxy instance information
          set_fact:
            saved_proxy_instance_id: "{{ proxy_instance_id }}"
            saved_proxy_instance_ip: "{{ proxy_instance_ip }}"
            saved_proxy_instance_private_ip: "{{ proxy_instance_private_ip }}"
            cacheable: yes
          when: disable_http2 | bool and proxy_instance_ip is defined

        - name: Add Linux proxy host to inventory
          add_host:
            hostname: "{{ proxy_instance_ip }}"
            groupname: proxy_hosts
            ansible_host: "{{ proxy_instance_ip }}"
            ansible_user: fedora
            ansible_ssh_private_key_file: "./{{ key_pair_name }}.pem"
            ansible_connection: ssh
            ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
            instance_id: "{{ proxy_instance_id }}"
            private_ip: "{{ proxy_instance_private_ip }}"
          when: disable_http2 | bool and proxy_instance_ip is defined

      rescue:
        - name: Handle deployment failure
          debug:
            msg: |
              Deployment failed. Please fix the issues and re-run with action=deploy or cleanup with action=cleanup.

        - name: Fail the playbook
          fail:
            msg: "Deployment failed - see error above"
      
      when: action == "deploy"

- name: Stop EC2 instance
  hosts: localhost
  gather_facts: false
  vars_files:
    - ./vars
  vars:
    aws_region: "us-east-1"
    resource_prefix: "{{ guid }}"
    instance_name: "{{ resource_prefix }}-instance"
  tasks:
    - name: Lookup EC2 instance ID by Name tag
      amazon.aws.ec2_instance_info:
        region: "{{ aws_region }}"
        filters:
          "tag:Name": "{{ instance_name }}"
          instance-state-name: [ "pending", "running", "stopping", "stopped" ]
      register: ec2_lookup
      when: action == "stop"

    - name: Fail if no instance found with given name
      fail:
        msg: "No EC2 instance found with Name tag '{{ instance_name }}'."
      when:
        - action == "stop"
        - ec2_lookup.instances | length == 0

    - name: Stop EC2 instance by ID
      amazon.aws.ec2_instance:
        instance_ids:
          - "{{ ec2_lookup.instances[0].instance_id }}"
        region: "{{ aws_region }}"
        state: stopped
        wait: true
        wait_timeout: 300
      when: action == "stop"

- name: Configure mitmproxy with WireGuard mode on Linux proxy
  hosts: proxy_hosts
  gather_facts: true
  become: true
  vars_files:
    - ./vars
  tasks:
    - block:
        - name: Update system packages
          dnf:
            name: '*'
            state: latest
            update_cache: yes

        - name: Install required packages
          dnf:
            name:
              - python3-pip
              - python3-packaging
              - python3-setuptools
              - iptables
              - wireguard-tools
            state: present

        - name: Install mitmproxy via pip
          pip:
            name: mitmproxy
            state: present
            executable: pip3

        - name: Enable IP forwarding
          sysctl:
            name: net.ipv4.ip_forward
            value: '1'
            sysctl_set: yes
            state: present
            reload: yes

        - name: Create mitmproxy configuration directory
          file:
            path: /root/.mitmproxy
            state: directory
            mode: '0700'

        - name: Start mitmproxy in foreground to generate WireGuard config
          shell: |
            timeout 10 /usr/local/bin/mitmdump --mode wireguard --no-http2 --set confdir=/root/.mitmproxy 2>&1 | tee /tmp/mitmproxy-startup.log || true
          async: 15
          poll: 0
          register: mitmproxy_startup

        - name: Wait for mitmproxy to initialize and generate config
          pause:
            seconds: 12

        - name: Check mitmproxy startup result
          async_status:
            jid: "{{ mitmproxy_startup.ansible_job_id }}"
          register: mitmproxy_job_result
          failed_when: false

        - name: Extract WireGuard client configuration from mitmproxy log
          shell: grep -A 8 '\[Interface\]' /tmp/mitmproxy-startup.log > /tmp/wireguard-client.conf
          args:
            executable: /bin/bash

        - name: Update Endpoint in WireGuard config to use public IP
          replace:
            path: /tmp/wireguard-client.conf
            regexp: 'Endpoint = .*'
            replace: 'Endpoint = {{ ansible_host }}:51820'

        - name: Disable kill-switch by splitting AllowedIPs range
          replace:
            path: /tmp/wireguard-client.conf
            regexp: '^AllowedIPs = 0\.0\.0\.0/0.*$'
            replace: 'AllowedIPs = 0.0.0.0/1, 128.0.0.0/1'

        - name: Verify WireGuard client config was extracted
          stat:
            path: /tmp/wireguard-client.conf
          register: wg_client_conf_stat

        - name: Display extracted config for debugging
          shell: cat /tmp/wireguard-client.conf
          register: wg_conf_content
          when: wg_client_conf_stat.stat.exists

        - name: Show WireGuard config
          debug:
            msg: "{{ wg_conf_content.stdout }}"
          when: wg_client_conf_stat.stat.exists

        - name: Fetch WireGuard client configuration to localhost
          fetch:
            src: /tmp/wireguard-client.conf
            dest: ./wireguard-client.conf
            flat: yes
          when: wg_client_conf_stat.stat.exists and wg_client_conf_stat.stat.size > 0

        - name: Wait for mitmproxy CA certificate to be generated
          wait_for:
            path: /root/.mitmproxy/mitmproxy-ca-cert.cer
            timeout: 30

        - name: Fetch mitmproxy CA certificate to localhost
          fetch:
            src: /root/.mitmproxy/mitmproxy-ca-cert.cer
            dest: ./mitmproxy-ca-cert.cer
            flat: yes

        - name: Create mitmproxy systemd service
          copy:
            content: |
              [Unit]
              Description=mitmproxy in WireGuard mode with HTTP/2 disabled
              After=network.target

              [Service]
              Type=simple
              User=root
              WorkingDirectory=/root
              ExecStart=/usr/local/bin/mitmdump --mode wireguard --no-http2 --set confdir=/root/.mitmproxy
              Restart=always
              RestartSec=3

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/mitmproxy-wireguard.service
            mode: '0644'

        - name: Enable and start mitmproxy-wireguard service
          systemd:
            name: mitmproxy-wireguard
            enabled: yes
            state: started
            daemon_reload: yes

      when: hostvars['localhost']['action'] == "deploy" and hostvars['localhost']['disable_http2'] | default(false) | bool

- name: Install extension on Windows instance
  hosts: windows_hosts
  gather_facts: false
  vars_files:
    - ./vars
  vars:
    windows_user: NonAdmin
    windows_password: "{{ ansible_password }}"
    github_repos:
    - https://github.com/konveyor-ecosystem/coolstore
    clone_root: "C:/Users/{{ windows_user }}/repos"
  tasks:
    - block:
        - name: Wait for system to be fully ready
          win_wait_for:
            timeout: 60
          retries: 60
          delay: 5
          register: system_ready
          until: system_ready is succeeded

        - name: Create NonAdmin user account
          win_user:
            name: NonAdmin
            password: "{{ ansible_password }}"
            password_never_expires: yes
            state: present
            groups:
              - Users
            description: "Non-administrative user for development"

        - name: Enable RDP access for NonAdmin user
          win_shell: |
            # Add NonAdmin to Remote Desktop Users group
            Add-LocalGroupMember -Group "Remote Desktop Users" -Member "NonAdmin" -ErrorAction SilentlyContinue

        - name: Create temp directory if it doesn't exist
          win_file:
            path: C:\temp
            state: directory

        - name: Create C# code file for CreateProfile API
          win_copy:
            content: |
              [DllImport("Userenv.dll", CharSet = CharSet.Unicode, SetLastError = true)]
              public static extern int CreateProfile(
                  [MarshalAs(UnmanagedType.LPWStr)] string pszUserSid,
                  [MarshalAs(UnmanagedType.LPWStr)] string pszUserName,
                  [MarshalAs(UnmanagedType.LPWStr)] System.Text.StringBuilder pszProfilePath,
                  uint cchProfilePath
              );
            dest: C:\temp\CreateProfile.cs

        - name: Create PowerShell script for profile creation
          win_copy:
            content: |
              $userName = "NonAdmin"

              try {
                $objUser = New-Object System.Security.Principal.NTAccount($userName)
                $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
                $userSid = $strSID.Value
                Write-Output "User SID: $userSid"
              }
              catch {
                Write-Error "Failed to get SID for user $userName : $_"
                exit 1
              }

              $createProfileCode = Get-Content C:\temp\CreateProfile.cs -Raw
              Add-Type -Namespace 'Profiles' -Name 'UserProfile' -MemberDefinition $createProfileCode

              $profilePath = New-Object System.Text.StringBuilder 260
              $result = [Profiles.UserProfile]::CreateProfile($userSid, $userName, $profilePath, $profilePath.Capacity)

              if ($result -eq 0) {
                $path = $profilePath.ToString()
                Write-Output "SUCCESS: Profile created at: $path"
              }
              elseif ($result -eq 0x800700B7) {
                Write-Output "Profile already exists"
                $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
                  $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
                } | Select-Object -First 1
                if ($profile) {
                  $profilePath = $profile.LocalPath
                  Write-Output "Existing profile at: $profilePath"
                }
              }
              else {
                $exception = [System.Runtime.InteropServices.Marshal]::GetExceptionForHR($result)
                $hexResult = $result.ToString('X8')
                $errorMsg = $exception.Message
                Write-Error "Failed to create profile: $errorMsg (HRESULT: 0x$hexResult)"
                exit 1
              }

              Start-Sleep -Seconds 2
              $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
                $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
              } | Select-Object -First 1

              if ($profile) {
                $profilePath = $profile.LocalPath
                Write-Output "Profile verified at: $profilePath"
              } else {
                Write-Error "Profile not found after CreateProfile"
                exit 1
              }
            dest: C:\temp\Create-UserProfile.ps1

        - name: Create user profile using CreateProfile API
          win_shell: C:\temp\Create-UserProfile.ps1
          register: profile_creation

        - name: Display profile creation result
          debug:
            msg: "{{ profile_creation.stdout_lines }}"

        - name: Install Chocolatey
          win_shell: |
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

        - name: Install Node.js
          win_chocolatey:
            name: nodejs
            state: present

        - name: Install Java (OpenJDK)
          win_chocolatey:
            name: openjdk
            state: present

        - name: Ensure JAVA_HOME and PATH are configured for JDK
          win_shell: |
            $candidates = @(
              'C:\\Program Files\\Microsoft',
              'C:\\Program Files\\OpenJDK',
              'C:\\Program Files\\Java'
            )
            $javaHome = $null
            foreach ($base in $candidates) {
              if (Test-Path $base) {
                $dirs = Get-ChildItem -Path $base -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match 'jdk' }
                if ($dirs) {
                  $javaHome = ($dirs | Sort-Object Name -Descending | Select-Object -First 1).FullName
                  break
                }
              }
            }
            if (-not $javaHome) {
              $javaExe = (Get-Command java.exe -ErrorAction SilentlyContinue).Path
              if ($javaExe) { $javaHome = (Split-Path (Split-Path $javaExe -Parent) -Parent) }
            }
            if (-not $javaHome) { Write-Error 'Unable to locate JDK home after installation'; exit 1 }
            # Set JAVA_HOME at Machine scope
            [Environment]::SetEnvironmentVariable('JAVA_HOME', $javaHome, 'Machine')
            # Ensure %JAVA_HOME%\bin is in Machine PATH
            $machinePath = [Environment]::GetEnvironmentVariable('PATH','Machine')
            $javaBin = Join-Path $javaHome 'bin'
            if ($machinePath -notlike ("*" + $javaBin + "*")) {
              [Environment]::SetEnvironmentVariable('PATH', ($machinePath + ';' + $javaBin), 'Machine')
            }
            # Also set for current process so subsequent tasks see it
            $processPath = [Environment]::GetEnvironmentVariable('PATH','Process')
            if ($processPath -notlike ("*" + $javaBin + "*")) {
              [Environment]::SetEnvironmentVariable('PATH', ($processPath + ';' + $javaBin), 'Process')
            }
            [Environment]::SetEnvironmentVariable('JAVA_HOME', $javaHome, 'Process')
            Write-Output "JAVA_HOME set to: $javaHome"
            # Use a constrained heap to avoid large G1 reservations in low commit-limit environments
            java -Xms64m -Xmx256m -version

        - name: Ensure system pagefile is enabled (increase commit limit)
          win_shell: |
            try {
              $sys = Get-WmiObject -Class Win32_ComputerSystem
              if (-not $sys.AutomaticManagedPagefile) {
                wmic computersystem where name="%computername%" set AutomaticManagedPagefile=True | Out-Null
                Write-Output "Enabled Automatic Managed Pagefile"
              } else {
                Write-Output "Automatic Managed Pagefile already enabled"
              }
            } catch {
              Write-Output "Failed to ensure pagefile settings: $($_.Exception.Message)"
            }

        - name: Install Maven
          win_chocolatey:
            name: maven
            state: present

        - name: Ensure MAVEN_HOME and PATH include Maven bin
          win_shell: |
            $mvn = $null
            $mvnCandidates = @(
              (Get-Command mvn.exe -ErrorAction SilentlyContinue).Path,
              (Get-Command mvn.cmd -ErrorAction SilentlyContinue).Path
            ) | Where-Object { $_ -and $_.Trim().Length -gt 0 }
            if ($mvnCandidates -and $mvnCandidates.Count -gt 0) { $mvn = $mvnCandidates[0] }

            $mavenHome = $null
            if ($mvn -and (Test-Path $mvn)) {
              $mvnDir = Split-Path $mvn -Parent
              if ($mvnDir) {
                $candidateHome = Split-Path $mvnDir -Parent
                if ($candidateHome -and (Test-Path (Join-Path $candidateHome 'bin'))) {
                  $mavenHome = $candidateHome
                }
              }
            }
            if (-not $mavenHome) {
              $pkgRoot = 'C:\\ProgramData\\chocolatey\\lib\\maven'
              if (Test-Path $pkgRoot) {
                $pkgDir = Get-ChildItem -Path $pkgRoot -Directory -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                if ($pkgDir) {
                  $toolsDir = Join-Path $pkgDir.FullName 'tools'
                  $searchRoots = @()
                  if (Test-Path $toolsDir) { $searchRoots += $toolsDir }
                  $searchRoots += $pkgDir.FullName
                  foreach ($root in $searchRoots) {
                    if (Test-Path $root) {
                      $apacheDir = Get-ChildItem -Path $root -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -like 'apache-maven-*' } | Sort-Object Name -Descending | Select-Object -First 1
                      if ($apacheDir) { $mavenHome = $apacheDir.FullName; break }
                    }
                  }
                }
              }
            }
            if (-not $mavenHome) {
              Write-Output 'Could not resolve Maven home directory from Chocolatey package layout.'
            }
            if (-not $mavenHome -or -not (Test-Path $mavenHome)) {
              Write-Output "Could not determine MAVEN_HOME; mvn may still be on PATH via Chocolatey shim."
            } else {
              [Environment]::SetEnvironmentVariable('MAVEN_HOME', $mavenHome, 'Machine')
              $machinePath = [Environment]::GetEnvironmentVariable('PATH','Machine')
              $mvnBin = Join-Path $mavenHome 'bin'
              if ($machinePath -notlike ("*" + $mvnBin + "*")) {
                [Environment]::SetEnvironmentVariable('PATH', ($machinePath + ';' + $mvnBin), 'Machine')
              } 
              $procPath = [Environment]::GetEnvironmentVariable('PATH','Process')
              if ($procPath -notlike ("*" + $mvnBin + "*")) {
                [Environment]::SetEnvironmentVariable('PATH', ($procPath + ';' + $mvnBin), 'Process')
              }
              Write-Output "MAVEN_HOME set to: $mavenHome"
              mvn -version
            }

        - name: Install VSCode
          win_chocolatey:
            name: vscode
            state: present

        - name: Install Git
          win_chocolatey:
            name: git
            state: present

        - name: Refresh environment variables
          win_shell: |
            $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH","User")
            [Environment]::SetEnvironmentVariable("PATH", $env:PATH, "Process")

        - name: Get latest Konveyor extension release from GitHub
          uri:
            url: https://api.github.com/repos/konveyor/editor-extensions/releases/latest
            method: GET
            return_content: yes
            headers:
              Accept: application/vnd.github+json
          register: latest_release
          delegate_to: localhost
          when: konveyor_extension_url is not defined

        - name: Find VSIX asset in latest release
          set_fact:
            konveyor_extension_url: "{{ latest_release.json.assets | selectattr('name', 'match', '.*\\.vsix$') | map(attribute='browser_download_url') | first }}"
          when: konveyor_extension_url is not defined and latest_release.json.assets is defined

        - name: Display extension URL being used
          debug:
            msg: "Using extension URL: {{ konveyor_extension_url }}"
          when: konveyor_extension_url is defined

        - name: Create temp directory if it doesn't exist
          win_file:
            path: "C:\\temp"
            state: directory
          when: konveyor_extension_url is defined

        - name: Compute effective artifact zip URL for GitHub Actions page links
          set_fact:
            konveyor_effective_zip_url: "{{ konveyor_extension_url | regex_replace('^https://github.com/([^/]+)/([^/]+)/actions/runs/\\d+/artifacts/(\\d+).*$', 'https://api.github.com/repos/\\1/\\2/actions/artifacts/\\3/zip') }}"
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$'))

        - name: Download Konveyor extension VSIX (direct)
          win_get_url:
            url: "{{ konveyor_extension_url }}"
            dest: "C:\\temp\\konveyor-extension.vsix"
            force: true
            timeout: 300
          when: konveyor_extension_url is defined and (konveyor_extension_url | lower is match('.*\\.vsix$'))
          register: vsix_download_direct

        - name: Download Konveyor extension archive (zip)
          win_get_url:
            url: "{{ konveyor_effective_zip_url | default(konveyor_extension_url) }}"
            dest: "C:\\temp\\konveyor-extension.zip"
            force: true
            timeout: 300
            headers:
              Authorization: "Bearer {{ gh_token }}"
              Accept: "application/vnd.github+json"
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$'))
          register: vsix_archive_download

        - name: Unzip Konveyor extension archive
          win_unzip:
            src: "C:\\temp\\konveyor-extension.zip"
            dest: "C:\\temp\\konveyor-extension-unpacked"
            overwrite: true
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$'))

        - name: Find VSIX inside unzipped archive
          win_find:
            paths: "C:\\temp\\konveyor-extension-unpacked"
            patterns:
              - "*.vsix"
            file_type: file
            recurse: yes
          register: found_vsix_in_archive
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$'))

        - name: Fail if no VSIX found in archive
          fail:
            msg: "No .vsix found in downloaded archive"
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$')) and ((found_vsix_in_archive.matched | default(0)) | int == 0)

        - name: Copy VSIX from unzipped archive
          win_copy:
            src: "{{ (found_vsix_in_archive.files | map(attribute='path') | list)[0] }}"
            dest: "C:\\temp\\konveyor-extension.vsix"
            remote_src: true
          when: konveyor_extension_url is defined and not (konveyor_extension_url | lower is match('.*\\.vsix$')) and ((found_vsix_in_archive.matched | default(0)) | int > 0)

        - name: Verify VSIX file was downloaded successfully
          win_stat:
            path: "C:\\temp\\konveyor-extension.vsix"
          register: vsix_file_check
          when: konveyor_extension_url is defined

        - name: Create reusable VSIX installation function
          win_shell: |
            # Define the function in a file so it can be reused
            $functionDef = @'
            function Install-VSCodeExtension {
              param(
                [Parameter(Mandatory=$true)]
                [string]$VsixPath,
                [Parameter(Mandatory=$true)]
                [string]$ProfilePath
              )

              $extensionName = [System.IO.Path]::GetFileNameWithoutExtension($VsixPath)
              $zipPath = "C:\temp\$extensionName.zip"
              $tempExtract = "C:\temp\$extensionName-extracted"

              if (-not (Test-Path $VsixPath)) {
                Write-Output "VSIX file not found at $VsixPath, skipping"
                return
              }

              Write-Output "Processing VSIX: $VsixPath"
              Copy-Item -Path $VsixPath -Destination $zipPath -Force

              Write-Output "Extracting ZIP from $zipPath to $tempExtract"
              Expand-Archive -Path $zipPath -DestinationPath $tempExtract -Force

              Write-Output "Extracted VSIX structure:"
              Get-ChildItem $tempExtract -Recurse -Depth 2 | Select-Object FullName | ForEach-Object { Write-Output $_.FullName }

              if (Test-Path "$tempExtract\extension\package.json") {
                $packageJsonPath = "$tempExtract\extension\package.json"
                $sourceDir = "$tempExtract\extension"
              } elseif (Test-Path "$tempExtract\package.json") {
                $packageJsonPath = "$tempExtract\package.json"
                $sourceDir = $tempExtract
              } else {
                Write-Error "Could not find package.json in extracted VSIX"
                return
              }

              Write-Output "Reading package.json from: $packageJsonPath"
              $packageJson = Get-Content $packageJsonPath -Raw | ConvertFrom-Json
              $publisher = $packageJson.publisher
              $name = $packageJson.name
              $version = $packageJson.version

              Write-Output "Extension: $publisher.$name version $version"

              $extensionsDir = Join-Path $ProfilePath ".vscode\extensions"
              New-Item -Path $extensionsDir -ItemType Directory -Force | Out-Null
              Write-Output "Created extensions directory: $extensionsDir"

              $extDir = Join-Path $extensionsDir "$publisher.$name-$version"
              New-Item -Path $extDir -ItemType Directory -Force | Out-Null
              Write-Output "Created extension directory: $extDir"

              Write-Output "Copying from $sourceDir to $extDir"
              Copy-Item -Path "$sourceDir\*" -Destination $extDir -Recurse -Force
              Write-Output "Successfully installed $publisher.$name version $version"

              Write-Output "Verifying installation:"
              Get-ChildItem $extDir | Select-Object Name | ForEach-Object { Write-Output "  - $($_.Name)" }
            }
            '@
            Set-Content -Path "C:\temp\Install-VSCodeExtension.ps1" -Value $functionDef
            Write-Output "VSIX installation function created"

        - name: Download redhat.java extension VSIX
          win_shell: |
            $url = "https://marketplace.visualstudio.com/_apis/public/gallery/publishers/redhat/vsextensions/java/latest/vspackage"
            $dest = "C:\temp\redhat.java.vsix"
            Write-Output "Downloading from $url"
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-WebRequest -Uri $url -OutFile $dest -UseBasicParsing -MaximumRedirection 5
            Write-Output "Download complete. File size: $((Get-Item $dest).Length) bytes"

        - name: Install redhat.java extension
          win_shell: |
            # Get NonAdmin profile path
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath

            # Load and call the reusable function
            . C:\temp\Install-VSCodeExtension.ps1
            Install-VSCodeExtension -VsixPath "C:\temp\redhat.java.vsix" -ProfilePath $profilePath

        - name: Install konveyor extension if present
          win_shell: |
            # Get NonAdmin profile path
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath

            # Load and call the reusable function
            . C:\temp\Install-VSCodeExtension.ps1
            Install-VSCodeExtension -VsixPath "C:\temp\konveyor-extension.vsix" -ProfilePath $profilePath

        - name: Create VSCode settings.json for NonAdmin
          win_shell: |
            # Get NonAdmin profile path (may have suffix)
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath
            Write-Output "Using profile path: $profilePath"

            # Create settings directory using actual profile path
            $settingsDir = Join-Path $profilePath "AppData\Roaming\Code\User"
            New-Item -Path $settingsDir -ItemType Directory -Force | Out-Null

            $settingsPath = Join-Path $settingsDir "settings.json"

            # Find JAVA_HOME
            $javaHome = [Environment]::GetEnvironmentVariable('JAVA_HOME','Machine')
            if (-not $javaHome -or !(Test-Path $javaHome)) {
              $candidates = 'C:\Program Files\OpenJDK','C:\Program Files\Microsoft','C:\Program Files\Java'
              foreach ($base in $candidates) {
                if (Test-Path $base) {
                  $dirs = Get-ChildItem -Path $base -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match 'jdk' }
                  if ($dirs) { $javaHome = ($dirs | Sort-Object Name -Descending | Select-Object -First 1).FullName; break }
                }
              }
            }

            # Build settings object
            $settings = @{
              "extensions.ignoreRecommendations" = $true
              "http.experimental.systemCertificatesV2" = $true
            }

            if ($javaHome -and (Test-Path $javaHome)) {
              $settings["java.jdt.ls.java.home"] = $javaHome
              $settings["java.configuration.runtimes"] = @(
                @{
                  name = "JavaSE"
                  path = $javaHome
                }
              )
            }

            # Write settings file
            $settings | ConvertTo-Json -Depth 10 | Set-Content -Path $settingsPath -Force

            Write-Output "Created settings.json at $settingsPath"
            Get-Content $settingsPath
          register: vscode_settings_result

        - name: Display VSCode settings configuration result
          debug:
            msg: "{{ vscode_settings_result.stdout_lines }}"

        - name: Fix ownership and permissions on VSCode directories
          win_shell: |
            # Get NonAdmin profile path (may have suffix)
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath

            $paths = @(
              (Join-Path $profilePath ".vscode"),
              (Join-Path $profilePath "AppData\Roaming\Code")
            )

            foreach ($path in $paths) {
              if (Test-Path $path) {
                Write-Output "Fixing permissions on $path"
                # Grant full control to NonAdmin user
                icacls $path /grant "NonAdmin:(OI)(CI)F" /T /Q
                # Transfer ownership to NonAdmin
                icacls $path /setowner "NonAdmin" /T /Q
              }
            }

            Write-Output "Permissions fixed successfully"

        - name: List installed extensions
          win_shell: |
            # Get NonAdmin profile path (may have suffix)
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath

            $extDir = Join-Path $profilePath ".vscode\extensions"
            if (Test-Path $extDir) {
              Write-Output "Extensions installed in $extDir"
              Get-ChildItem $extDir -Directory | ForEach-Object { Write-Output "  - $($_.Name)" }
            } else {
              Write-Output "Extensions directory not found"
            }
          register: installed_extensions

        - name: Display installed extensions
          debug:
            msg: "{{ installed_extensions.stdout_lines }}"

        - name: Clone GitHub repositories
          win_shell: |
            # Get NonAdmin profile path (may have suffix)
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if (-not $profile) {
              Write-Error "NonAdmin profile not found"
              exit 1
            }
            $profilePath = $profile.LocalPath
            Write-Output "Using profile path: $profilePath"

            # Create repos directory using actual profile path
            $repoDir = Join-Path $profilePath "repos"
            New-Item -Path $repoDir -ItemType Directory -Force | Out-Null

            Set-Location $repoDir

            $repos = @( {{ github_repos | map('to_json') | join(', ') }} )
            foreach ($repo in $repos) {
              $repoName = $repo.Split('/')[-1].Replace('.git','')
              if (!(Test-Path "$repoDir\$repoName")) {
                Write-Output "Cloning $repo..."
                git clone $repo
              } else {
                Write-Output "Repository $repoName already exists, skipping"
              }
            }

            Write-Output "Repository cloning complete"

        - name: Fix permissions on repos directory
          win_shell: |
            # Get NonAdmin profile path (may have suffix)
            $profile = Get-WmiObject -Class Win32_UserProfile | Where-Object {
              $_.LocalPath -like "*\NonAdmin*" -and -not $_.Special
            } | Select-Object -First 1

            if ($profile) {
              $profilePath = $profile.LocalPath
              $reposDir = Join-Path $profilePath "repos"

              if (Test-Path $reposDir) {
                icacls $reposDir /grant "NonAdmin:(OI)(CI)F" /T /Q
                icacls $reposDir /setowner "NonAdmin" /T /Q
                Write-Output "Permissions fixed on repos directory: $reposDir"
              }
            }

        - name: Install WireGuard Windows client
          win_chocolatey:
            name: wireguard
            state: present
          when: hostvars['localhost']['disable_http2'] | default(false) | bool

        - name: Check if WireGuard config file exists on controller
          stat:
            path: ./wireguard-client.conf
          delegate_to: localhost
          register: wg_config_stat
          when: hostvars['localhost']['disable_http2'] | default(false) | bool

        - name: Read WireGuard configuration from controller
          set_fact:
            wg_config_content: "{{ lookup('file', './wireguard-client.conf') }}"
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and wg_config_stat.stat.exists

        - name: Create WireGuard configuration directory
          win_file:
            path: "C:\\Program Files\\WireGuard\\Data\\Configurations"
            state: directory
          when: hostvars['localhost']['disable_http2'] | default(false) | bool

        - name: Create WireGuard tunnel configuration on Windows
          win_copy:
            content: "{{ wg_config_content }}"
            dest: "C:\\Program Files\\WireGuard\\Data\\Configurations\\mitmproxy.conf"
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and wg_config_content is defined

        - name: Import and start WireGuard tunnel
          win_shell: |
            $tunnelName = "mitmproxy"
            $configPath = "C:\Program Files\WireGuard\Data\Configurations\mitmproxy.conf"

            # Install tunnel service
            & "C:\Program Files\WireGuard\wireguard.exe" /installtunnelservice $configPath

            Start-Sleep -Seconds 3

            # Set the WireGuard tunnel service to start automatically
            $serviceName = "WireGuardTunnel`$$tunnelName"
            Set-Service -Name $serviceName -StartupType Automatic

            # Start the tunnel
            Start-Service -Name $serviceName
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and wg_config_content is defined

        - name: Verify WireGuard tunnel is running
          win_shell: |
            $tunnelName = "mitmproxy"
            $serviceName = "WireGuardTunnel`$$tunnelName"

            # Check service status
            $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
            if ($service) {
              Write-Output "Service: $($service.Name)"
              Write-Output "Status: $($service.Status)"
              Write-Output "StartType: $($service.StartType)"
            } else {
              Write-Output "WireGuard service not found"
            }

            # Show WireGuard interface status
            & "C:\Program Files\WireGuard\wireguard.exe" /dumplog $tunnelName 2>&1 | Select-Object -Last 10
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and wg_config_content is defined
          register: wg_status
          failed_when: false

        - name: Display WireGuard tunnel status
          debug:
            msg: "{{ wg_status.stdout_lines }}"
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and wg_status is defined and wg_status.stdout_lines is defined

        - name: Check if mitmproxy CA certificate exists on controller
          stat:
            path: ./mitmproxy-ca-cert.cer
          delegate_to: localhost
          register: mitm_ca_stat
          when: hostvars['localhost']['disable_http2'] | default(false) | bool

        - name: Copy mitmproxy CA certificate to Windows
          win_copy:
            src: ./mitmproxy-ca-cert.cer
            dest: "C:\\temp\\mitmproxy-ca-cert.cer"
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and mitm_ca_stat.stat.exists

        - name: Install mitmproxy CA certificate as trusted root CA
          win_shell: |
            $certPath = "C:\temp\mitmproxy-ca-cert.cer"

            # Import the certificate into the Trusted Root Certification Authorities store
            Import-Certificate -FilePath $certPath -CertStoreLocation Cert:\LocalMachine\Root

            Write-Output "Mitmproxy CA certificate installed successfully"

            # Verify installation
            $thumbprint = (Get-PfxCertificate -FilePath $certPath).Thumbprint
            $installed = Get-ChildItem -Path Cert:\LocalMachine\Root | Where-Object { $_.Thumbprint -eq $thumbprint }

            if ($installed) {
              Write-Output "Certificate verified in Trusted Root store"
              Write-Output "Thumbprint: $thumbprint"
            } else {
              Write-Error "Certificate installation verification failed"
            }
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and mitm_ca_stat.stat.exists
          register: ca_install_result

        - name: Display CA certificate installation result
          debug:
            msg: "{{ ca_install_result.stdout_lines }}"
          when: hostvars['localhost']['disable_http2'] | default(false) | bool and ca_install_result is defined and ca_install_result.stdout_lines is defined

      when: hostvars['localhost']['action'] == "deploy"

- name: Cleanup AWS resources
  hosts: localhost
  gather_facts: false
  vars_files:
    - ./vars
  vars:
    aws_region: "us-east-1"
    ec2_instance_type: "m5.4xlarge"
    resource_prefix: "{{ guid }}"
    instance_name: "{{ resource_prefix }}-instance"
    vpc_name: "{{ resource_prefix }}-vpc"
    subnet_name: "{{ resource_prefix }}-subnet"
    igw_name: "{{ resource_prefix }}-igw"
    route_table_name: "{{ resource_prefix }}-rt"
    security_group_name: "{{ resource_prefix }}-sg"
    key_pair_name: "{{ resource_prefix }}-keypair"
    cleanup_resources: true # cleans up all dependent resources
    winrm_wait_timeout: 180 # 3 minutes default wait for WinRM
  tasks:
    - name: Validate required variables for cleanup
      fail:
        msg: "Required variable {{ item }} is not defined"
      when: (vars[item] is not defined or vars[item] == "") and action == "cleanup"
      loop:
        - aws_access_key_id
        - aws_secret_access_key
        - action

    - block:
        # Initialize cleanup tracking variables
        - name: Initialize cleanup tracking variables
          set_fact:
            resources_cleaned: []
            cleanup_errors: []
            cleanup_successful: true

        # Lookup resources by name to get their IDs dynamically
        - name: Lookup EC2 instance by name
          amazon.aws.ec2_instance_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ resource_prefix }}-instance"
              instance-state-name: ["pending", "running", "stopped", "stopping"]
          register: instance_lookup

        - name: Lookup proxy EC2 instance by name
          amazon.aws.ec2_instance_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ resource_prefix }}-proxy-instance"
              instance-state-name: ["pending", "running", "stopped", "stopping"]
          register: proxy_instance_lookup

        - name: Lookup VPC by name
          amazon.aws.ec2_vpc_net_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ resource_prefix }}-vpc"
          register: vpc_lookup

        - name: Lookup security group by name
          amazon.aws.ec2_security_group_info:
            region: "{{ aws_region }}"
            filters:
              group-name: "{{ resource_prefix }}-sg"
          register: sg_lookup

        - name: Lookup proxy security group by name
          amazon.aws.ec2_security_group_info:
            region: "{{ aws_region }}"
            filters:
              group-name: "{{ resource_prefix }}-proxy-sg"
          register: proxy_sg_lookup

        - name: Lookup subnet by name
          amazon.aws.ec2_vpc_subnet_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ resource_prefix }}-subnet"
          register: subnet_lookup

        - name: Lookup route table by name
          amazon.aws.ec2_vpc_route_table_info:
            region: "{{ aws_region }}"
            filters:
              "tag:Name": "{{ resource_prefix }}-rt"
          register: rt_lookup

        # Set resource IDs from lookups
        - name: Set resource IDs from lookups
          set_fact:
            found_instance_id: "{{ instance_lookup.instances[0].instance_id if (instance_lookup.instances is defined and instance_lookup.instances | length > 0) else '' }}"
            found_proxy_instance_id: "{{ proxy_instance_lookup.instances[0].instance_id if (proxy_instance_lookup.instances is defined and proxy_instance_lookup.instances | length > 0) else '' }}"
            found_vpc_id: "{{ vpc_lookup.vpcs[0].vpc_id if (vpc_lookup.vpcs is defined and vpc_lookup.vpcs | length > 0) else '' }}"
            found_sg_id: "{{ sg_lookup.security_groups[0].group_id if (sg_lookup.security_groups is defined and sg_lookup.security_groups | length > 0) else '' }}"
            found_proxy_sg_id: "{{ proxy_sg_lookup.security_groups[0].group_id if (proxy_sg_lookup.security_groups is defined and proxy_sg_lookup.security_groups | length > 0) else '' }}"
            found_subnet_id: "{{ subnet_lookup.subnets[0].subnet_id if (subnet_lookup.subnets is defined and subnet_lookup.subnets | length > 0) else '' }}"
            found_subnet_cidr: "{{ subnet_lookup.subnets[0].cidr_block if (subnet_lookup.subnets is defined and subnet_lookup.subnets | length > 0) else '' }}"
            found_rt_id: "{{ rt_lookup.route_tables[0].route_table_id if (rt_lookup.route_tables is defined and rt_lookup.route_tables | length > 0) else '' }}"

        - name: Display found resources
          debug:
            msg: |
              Found resources to clean up:
              - Instance ID: {{ found_instance_id | default('Not found') }}
              - Proxy Instance ID: {{ found_proxy_instance_id | default('Not found') }}
              - VPC ID: {{ found_vpc_id | default('Not found') }}
              - Security Group ID: {{ found_sg_id | default('Not found') }}
              - Proxy Security Group ID: {{ found_proxy_sg_id | default('Not found') }}
              - Subnet ID: {{ found_subnet_id | default('Not found') }}
              - Subnet CIDR: {{ found_subnet_cidr | default('Not found') }}
              - Route Table ID: {{ found_rt_id | default('Not found') }}

        - name: Terminate EC2 instance
          amazon.aws.ec2_instance:
            instance_ids:
              - "{{ found_instance_id }}"
            region: "{{ aws_region }}"
            state: absent
            wait: true
            wait_timeout: 300
          when: found_instance_id != ""
          register: instance_cleanup
        
        - name: Track instance cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Instance: ' + found_instance_id] }}"
          when: instance_cleanup is not failed and found_instance_id != ""
        
        - name: Track instance cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to terminate instance: ' + found_instance_id] }}"
            cleanup_successful: false
          when: instance_cleanup is failed and found_instance_id != ""

        - name: Terminate proxy EC2 instance
          amazon.aws.ec2_instance:
            instance_ids:
              - "{{ found_proxy_instance_id }}"
            region: "{{ aws_region }}"
            state: absent
            wait: true
            wait_timeout: 300
          when: found_proxy_instance_id != ""
          register: proxy_instance_cleanup

        - name: Track proxy instance cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Proxy Instance: ' + found_proxy_instance_id] }}"
          when: proxy_instance_cleanup is not failed and found_proxy_instance_id != ""

        - name: Track proxy instance cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to terminate proxy instance: ' + found_proxy_instance_id] }}"
            cleanup_successful: false
          when: proxy_instance_cleanup is failed and found_proxy_instance_id != ""

        - name: Remove key pair
          amazon.aws.ec2_key:
            name: "{{ resource_prefix }}-keypair"
            region: "{{ aws_region }}"
            state: absent
          when: cleanup_resources | bool
          register: keypair_cleanup
        
        - name: Track key pair cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Key pair: ' + resource_prefix + '-keypair'] }}"
          when: keypair_cleanup is not failed
        
        - name: Track key pair cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove key pair: ' + resource_prefix + '-keypair'] }}"
            cleanup_successful: false
          when: keypair_cleanup is failed

        - name: Remove security group
          amazon.aws.ec2_security_group:
            group_id: "{{ found_sg_id }}"
            region: "{{ aws_region }}"
            state: absent
          when: cleanup_resources | bool and found_sg_id != ""
          register: sg_cleanup
        
        - name: Track security group cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Security group: ' + found_sg_id] }}"
          when: sg_cleanup is not failed and found_sg_id != ""
        
        - name: Track security group cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove security group: ' + found_sg_id] }}"
            cleanup_successful: false
          when: sg_cleanup is failed and found_sg_id != ""

        - name: Remove proxy security group
          amazon.aws.ec2_security_group:
            group_id: "{{ found_proxy_sg_id }}"
            region: "{{ aws_region }}"
            state: absent
          when: cleanup_resources | bool and found_proxy_sg_id != ""
          register: proxy_sg_cleanup

        - name: Track proxy security group cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Proxy Security group: ' + found_proxy_sg_id] }}"
          when: proxy_sg_cleanup is not failed and found_proxy_sg_id != ""

        - name: Track proxy security group cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove proxy security group: ' + found_proxy_sg_id] }}"
            cleanup_successful: false
          when: proxy_sg_cleanup is failed and found_proxy_sg_id != ""

        - name: Remove route table
          amazon.aws.ec2_vpc_route_table:
            route_table_id: "{{ found_rt_id }}"
            region: "{{ aws_region }}"
            state: absent
            lookup: id
          when: cleanup_resources | bool and found_rt_id != ""
          register: rt_cleanup
        
        - name: Track route table cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Route table: ' + found_rt_id] }}"
          when: rt_cleanup is not failed and found_rt_id != ""
        
        - name: Track route table cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove route table: ' + found_rt_id] }}"
            cleanup_successful: false
          when: rt_cleanup is failed and found_rt_id != ""

        - name: Remove subnet
          amazon.aws.ec2_vpc_subnet:
            region: "{{ aws_region }}"
            state: absent
            vpc_id: "{{ found_vpc_id }}"
            cidr: "{{ found_subnet_cidr }}"
          when: cleanup_resources | bool and found_subnet_id != "" and found_vpc_id != "" and found_subnet_cidr != ""
          register: subnet_cleanup
        
        - name: Track subnet cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Subnet: ' + found_subnet_id] }}"
          when: subnet_cleanup is not failed and found_subnet_id != ""
        
        - name: Track subnet cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove subnet: ' + found_subnet_id] }}"
            cleanup_successful: false
          when: subnet_cleanup is failed and found_subnet_id != ""

        - name: Remove internet gateway
          amazon.aws.ec2_vpc_igw:
            vpc_id: "{{ found_vpc_id }}"
            region: "{{ aws_region }}"
            state: absent
          when: cleanup_resources | bool and found_vpc_id != ""
          register: igw_cleanup
        
        - name: Track IGW cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['Internet Gateway in VPC: ' + found_vpc_id] }}"
          when: igw_cleanup is not failed and found_vpc_id != ""
        
        - name: Track IGW cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove Internet Gateway in VPC: ' + found_vpc_id] }}"
            cleanup_successful: false
          when: igw_cleanup is failed and found_vpc_id != ""

        - name: Remove VPC
          amazon.aws.ec2_vpc_net:
            vpc_id: "{{ found_vpc_id }}"
            region: "{{ aws_region }}"
            state: absent
          when: cleanup_resources | bool and found_vpc_id != ""
          register: vpc_cleanup
        
        - name: Track VPC cleanup
          set_fact:
            resources_cleaned: "{{ resources_cleaned + ['VPC: ' + found_vpc_id] }}"
          when: vpc_cleanup is not failed and found_vpc_id != ""
        
        - name: Track VPC cleanup error
          set_fact:
            cleanup_errors: "{{ cleanup_errors + ['Failed to remove VPC: ' + found_vpc_id] }}"
            cleanup_successful: false
          when: vpc_cleanup is failed and found_vpc_id != ""

        - name: Remove private key file
          file:
            path: "./{{ resource_prefix }}-keypair.pem"
            state: absent
          when: cleanup_resources | bool

        - name: Display cleanup completion
          debug:
            msg: |
              {% if cleanup_errors | length > 0 %}
              Cleanup completed with some errors:
              Errors encountered:
              {% for error in cleanup_errors %}
              - {{ error }}
              {% endfor %}
              
              Instance info file preserved due to errors.
              {% endif %}
              
              Resources successfully cleaned up:
              {% if resources_cleaned | length > 0 %}
              {% for resource in resources_cleaned %}
              - {{ resource }}
              {% endfor %}
              {% else %}
              - No resources found to clean up
              {% endif %}
              
              {% if cleanup_resources | bool %}
              Note: cleanup_resources was set to true - attempted to remove all infrastructure
              {% else %}
              Note: cleanup_resources was set to false - only instance was terminated
              {% endif %}
              
              {% if cleanup_successful | bool %}
               Cleanup completed successfully
              {% else %}
                Cleanup completed with errors
              {% endif %}

      when: action == "cleanup"

- name: Display connection information summary
  hosts: localhost
  gather_facts: false
  vars_files:
    - ./vars
  tasks:
    - block:
        - name: Build deployment summary message
          set_fact:
            summary_lines:
              - "================================================================================"
              - "DEPLOYMENT COMPLETE - CONNECTION INFORMATION"
              - "================================================================================"
              - ""
              - "Windows Instance:"
              - "-----------------"
              - "Instance ID: {{ hostvars['localhost']['windows_instance_id'] | default('N/A') }}"
              - "Public IP: {{ hostvars['localhost']['windows_instance_ip'] | default('N/A') }}"
              - ""
              - "RDP Connection (Administrator):"
              - "  Address: {{ hostvars['localhost']['windows_instance_ip'] | default('N/A') }}:3389"
              - "  Username: Administrator"
              - "  Password: {{ hostvars['localhost']['windows_admin_password'] | default('N/A') }}"
              - ""
              - "RDP Connection (NonAdmin - Development User):"
              - "  Address: {{ hostvars['localhost']['windows_instance_ip'] | default('N/A') }}:3389"
              - "  Username: NonAdmin"
              - "  Password: {{ hostvars['localhost']['nonadmin_password'] | default('N/A') }}"
              - "  Note: VS Code, extensions, and repositories configured for this user"
              - ""

        - name: Add proxy information to summary
          set_fact:
            summary_lines: "{{ summary_lines + proxy_info }}"
          vars:
            proxy_info:
              - "Proxy Instance (mitmproxy):"
              - "---------------------------"
              - "Instance ID: {{ hostvars['localhost']['saved_proxy_instance_id'] | default('N/A') }}"
              - "Public IP: {{ hostvars['localhost']['saved_proxy_instance_ip'] | default('N/A') }}"
              - "Private IP: {{ hostvars['localhost']['saved_proxy_instance_private_ip'] | default('N/A') }}"
              - ""
              - "Mitmproxy Configuration:"
              - "  WireGuard endpoint: {{ hostvars['localhost']['saved_proxy_instance_ip'] | default('N/A') }}:51820"
              - "  HTTP/2: DISABLED"
              - "  CA certificate: ./mitmproxy-ca-cert.cer (installed on Windows)"
              - "  WireGuard config: ./wireguard-client.conf"
              - ""
              - "WireGuard on Windows:"
              - "  Tunnel name: mitmproxy"
              - "  Auto-start: ENABLED"
              - "  Kill-switch: DISABLED (traffic allowed if tunnel down)"
              - "  Status: All traffic routed through mitmproxy"
              - ""
              - "Files saved locally:"
              - "  - wireguard-client.conf"
              - "  - mitmproxy-ca-cert.cer"
              - ""
          when: disable_http2 | default(false) | bool

        - name: Add closing line to summary
          set_fact:
            summary_lines: "{{ summary_lines + ['================================================================================'] }}"

        - name: Display deployment summary
          debug:
            msg: "{{ summary_lines }}"

      when: action == "deploy"
